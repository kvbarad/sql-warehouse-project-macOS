# MySQL Query Section
# Overview

The MySQL queries demonstrate a variety of business rules related to sales, customers, employees, and orders data within a typical sales database. These business rules pertain to data classification, aggregation, ranking, filtration, and reporting.

### Key Business Rules

1. Customer Score Categorization
Customers are categorized based on their score into:
High Score: score > 500
Medium Score: score between 400 and 500
Low Score: score between 100 and 400
No Score: NULL or scores outside above ranges
Customer full names are generated by concatenating first and last names, with placeholders for missing last names.
Sales Aggregation per Customer
Calculate total orders (COUNT(*)), total sales (SUM(sales)), average sales (AVG(sales)), maximum sales (MAX(sales)), and minimum sales (MIN(sales)) grouped by each customer.
Sales Aggregation per Product
Aggregate sales per product and per product combined with order status using window functions.
Sales Ranking and Ordering
Rank orders by sales amount using functions like ROW_NUMBER(), RANK(), and DENSE_RANK(), providing sequences that help identify top performing orders/products/customers.
Cumulative and Moving Aggregations
Compute running totals, cumulative sums, and moving averages over partitions like product or order date.
Frame specifications (e.g., ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) control which rows participate in cumulative calculations.
Duplicate Detection and Data De-duplication
Identify duplicate records in orders archive using the count window function, and select unique rows by filtering the first occurrence (ROW_NUMBER() = 1).
Bucket and Quantile Analysis using NTILE
Segment sales into buckets (e.g., low, medium, high) using NTILE() to divide data into approximately equal groups for distribution analysis.
Distribution and Percentile Measures
Use CUME_DIST() and PERCENT_RANK() to measure relative data distribution and percentile ranks of sales amounts.
Month-on-Month Sales Change Analysis
Calculate monthly sales totals, compare with previous months, and compute percentage growth or decline to monitor trends.
Customer Loyalty Analysis
Calculate average days between orders per customer using LEAD() and rank customers by frequency of order, measuring loyalty or engagement.
Metadata Exploration
Utilize INFORMATION_SCHEMA to investigate database structure and column details, supporting data discovery and validation.
Subquery and Join Principles
Apply scalar and correlated subqueries for counts and averages.
Use joins (including left joins) to combine dimensional customer/product/employee data with fact sales/orders.
Common Table Expressions (CTEs)
Implement CTEs to modularize complex queries for calculating total sales, last order dates, ranking, and segmentation of customers.
Recursive CTEs
Use recursive CTEs for hierarchical and sequence generation tasks such as building employee management hierarchies or number sequences.
Views and Reporting Tables
Create and maintain views to encapsulate complex joins and aggregations, enabling easier re-use and improved readability for reporting.
Security & Data Filtering
Sample security practice shown via filtered views (e.g., sales data excluding USA customers for EU-specific teams).
Document 2: How the MySQL Query Section Works
Overview

The MySQL queries presented serve as rich examples demonstrating data retrieval, transformation, aggregation, ranking, and reporting techniques, often leveraging advanced SQL constructs such as window functions, CTEs, and views.
Detailed Explanation

Data Classification using CASE and IF
Queries classify customers or sales values into categories by evaluating numeric thresholds in score or sales columns. This is performed in select statements using CASE or nested IF to return descriptive labels.
Aggregation and Grouping
GROUP BY clauses group rows by a specific column, e.g., customerid, enabling aggregations like total count of orders or total sales per customer.
Aggregate functions (SUM(), COUNT(), AVG(), etc.) operate on grouped data to produce summary statistics.
Window (Analytic) Functions
These functions (e.g., SUM() OVER, RANK() OVER, ROW_NUMBER() OVER, NTILE()) perform calculations across sets of rows related to the current row, without collapsing rows like GROUP BY.
Partitioning (PARTITION BY) scopes calculations to groups like individual products or customers.
Ordering (ORDER BY) within partitions determines the sequence for cumulative or ranking calculations.
Frame clauses (ROWS BETWEEN) specify the subset of rows over which aggregates are computed for rolling or cumulative metrics.
Duplicates Identification and Removal
Use ROW_NUMBER() partitioned by presumed key fields (e.g., orderid) to assign sequence numbers to duplicate rows.
Filter to keep only the first occurrence (e.g., UNIQID = 1), effectively deduplicating.
Bucketing with NTILE
To distribute the dataset roughly into equal parts, NTILE assigns each row in a sorted dataset a bucket number, enabling segmentation such as low/medium/high sales categories.
Rankings and Relative Positioning
RANK() and DENSE_RANK() assign rankings to rows with possible ties (same value same rank).
ROW_NUMBER() assigns unique, sequential numbers even if values tie.
Ranking functions can be partitioned or applied globally.
Cumulative Distribution Measures
CUME_DIST() gives the cumulative distribution value for a row (i.e., percentage of rows with less than or equal value).
PERCENT_RANK() calculates percentile rank scaled 0 to 1.
Using these functions aids in statistical insights like relative frequency and quantile groupings.
Month-over-Month Trend Analysis
Use LAG() window function to access previous month sales.
Subtract and divide by previous sales to compute change and percentage change, providing growth insights.
Customer Ranking by Loyalty
Calculate average days between orders per customer by leveraging LEAD() to find next order dates.
Assign ranks based on average days, indicating loyalty levels (lower avg days = higher loyalty).
Metadata Queries
Querying INFORMATION_SCHEMA.COLUMNS reveals database structure, important for understanding data types, constraints, and table designs.
Subqueries and Joins
Scalar subqueries retrieve aggregated data for use in filtering or display.
Joins (especially LEFT JOIN) combine dimension data (customers, products, employees) with fact data (orders) for enriched records.
Common Table Expressions (CTEs)
CTEs organize complex logic into named, reusable blocks.
Standalone CTEs select aggregations.
Nested CTEs chain multiple logical steps like total sales calculation, last order retrieval, ranking, and segmentation labeling.
Recursive CTEs allow iteration to build sequences or hierarchies.
Views and Reporting
Views encapsulate complex joins and aggregates, acting as virtual tables.
Can be created with CREATE OR REPLACE VIEW and queried repeatedly.
Supports consistent reporting layers and security filtering (e.g., different regional sales views).
Partitioning and Indexing (SQL Server Concepts)
The script references partitioning schemes, filegroups, and indexing for large datasets (mostly in SQL Server context) showing considerations for performance and data management.
